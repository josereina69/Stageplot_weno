<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stage Plot & Rider T√©cnico - Asistente de Programaci√≥n</title>
    
    <script src="https://unpkg.com/konva@9.3.0/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <style>
        :root {
            --color-primary: #1a237e; /* Azul oscuro/√≠ndigo */
            --color-secondary: #ffc107; /* Amarillo/√Åmbar */
            --color-background: #f4f5f8;
            /* Dimensiones Fijas: 900px (18m) x 600px (12m) */
            --stage-width-px: 900px; 
            --stage-height-px: 600px; 
            --sidebar-width: 200px; 
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--color-background);
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Contenedor principal para el PDF final */
        #documento-final {
            /* Se ajusta al ancho fijo del escenario + sidebar + gap */
            width: calc(var(--stage-width-px) + var(--sidebar-width) + 50px); 
            background-color: white;
            padding: 25px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            margin-bottom: 50px;
            position: relative;
        }
        
        /* HEADER (T√≠tulo del proyecto) */
        #header-documento {
            border-bottom: 3px solid var(--color-primary);
            padding-bottom: 12px;
            margin-bottom: 35px; 
            text-align: center;
        }
        
        /* ESTILO ADAPTADO PARA H1 (Editable) */
        #header-title-editable {
            font-size: 1.8em;
            font-weight: 700;
            width: 100%;
            min-height: 40px; 
            text-align: center;
            padding: 10px; 
            margin: 0; 
            white-space: pre-wrap; 
            border: 1px solid transparent; 
            box-sizing: border-box;
            line-height: 1.4;
        }
        #header-title-editable:hover {
            border: 1px dashed #ccc;
        }
        #header-title-editable:focus {
            outline: none;
            border: 1px solid var(--color-secondary);
        }

        /* ------------------------- */
        /* ZONA DE TRABAJO Y ESCENARIO */
        /* ------------------------- */
        
        #main-workspace {
            display: flex;
            gap: 20px; 
            width: 100%;
            /* Se ajusta al ancho fijo */
            max-width: calc(var(--stage-width-px) + var(--sidebar-width) + 50px); 
        }

        #herramientas {
            width: var(--sidebar-width); 
            min-width: var(--sidebar-width);
            flex-shrink: 0; 
            margin: 0; 
        }
        .categoria-header {
            background-color: var(--color-primary);
            color: white;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }
        .categoria-contenido {
            background-color: #fff;
            border: 1px solid #ddd;
            border-top: none;
            padding: 10px; 
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            display: flex;
            flex-wrap: wrap;
            gap: 8px; 
            justify-content: space-around;
        }
        .categoria-contenido.abierto {
            border-radius: 0 0 4px 4px;
        }

        /* ESTILO DE ICONOS ARRASTRABLES (MODIFICADO) */
        .icono-arrastrable {
            border: 2px solid var(--color-primary);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: grab;
            font-size: 0.9em;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            user-select: none;
            width: 75px; 
            transition: background-color 0.1s;
        }
        .icono-arrastrable:hover {
            background-color: #e8eaf6;
        }
        /* Estilo para las IM√ÅGENES DENTRO de los iconos arrastrables */
        .icono-arrastrable img { 
            width: 30px; 
            height: 30px; 
            margin-bottom: 5px;
            object-fit: contain; /* Asegura que la imagen se ajuste */
        }
        /* Estilo para iconos de Font Awesome */
        .icono-arrastrable i {
            font-size: 1.5em;
            margin-bottom: 5px;
            color: var(--color-primary);
        }
        /* Fin de estilo de iconos arrastrables */

        .control-grupo {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px;
            width: 100%; 
            box-sizing: border-box;
            justify-content: space-between;
        }
        #color-picker {
            width: 50px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
        }


        /* Contenedor del Escenario (Escenario + Reglas) */
        #contenedor-escenario {
            position: relative;
            /* Usar variables fijas + 30px de regla */
            width: calc(var(--stage-width-px) + 30px);
            height: calc(var(--stage-height-px) + 30px);
            margin: 0; 
            border: 1px solid #ddd;
            background-color: #fff;
            flex-grow: 1; 
            overflow: hidden; 
        }
        #stage-konva-container {
            position: absolute;
            left: 30px; /* Separaci√≥n para la regla izquierda */
            top: 0px;
            width: var(--stage-width-px);
            height: var(--stage-height-px);
            background-color: transparent;
            transform-origin: 0 0; 
        }

        /* Bot√≥n de Reset de Zoom */
        #btn-zoom-reset {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 100;
            background-color: white;
            border: 1px solid var(--color-primary);
            color: var(--color-primary);
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
            opacity: 0.8;
            width: 30px; 
            height: 30px;
        }
        
        /* Bot√≥n de Eliminar (NUEVO LUGAR) */
        #btn-eliminar-seleccionado-plano { 
            position: absolute;
            top: 45px; /* Separado del btn-zoom-reset */
            right: 5px;
            z-index: 100;
            background-color: #f44336; /* Rojo para borrar */
            color: white;
            border: none;
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
            opacity: 0.8;
            width: 30px; 
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #btn-eliminar-seleccionado-plano:disabled {
            background-color: #b0b0b0;
            cursor: not-allowed;
        }

        /* Reglas/Cotas */
        #ruler-bottom {
            position: absolute;
            bottom: 0;
            left: 30px;
            width: var(--stage-width-px);
            height: 30px;
            background-color: #e0e0e0;
            border-top: 1px solid #ccc;
            overflow: hidden; 
        }
        #ruler-left {
            position: absolute;
            top: 0; 
            left: 0;
            width: 30px;
            height: var(--stage-height-px);
            background-color: #e0e0e0;
            border-right: 1px solid #ccc;
            overflow: hidden; 
        }
        .ruler-tick {
            position: absolute;
            font-size: 10px;
            color: #555;
            text-align: center;
        }
        #ruler-bottom .ruler-tick {
            border-left: 1px solid #333;
            height: 5px;
            line-height: 30px;
            transform: translateY(0px);
        }
        #ruler-left .ruler-tick {
            width: 5px;
            border-bottom: 1px solid #333;
            line-height: 1;
            padding-right: 5px;
            text-align: right;
            transform: translateX(-1px);
        }

        /* Herramientas y Controles Superiores */
        #toolbar-gestion {
            width: 100%;
            /* Se ajusta al ancho fijo */
            max-width: calc(var(--stage-width-px) + var(--sidebar-width) + 50px);
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px;
            margin-top: 10px;
        }
        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .toolbar-group button {
            background-color: var(--color-primary);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .toolbar-group button:hover {
            background-color: #3949ab;
        }
        .toolbar-group button:disabled {
            background-color: #b0b0b0;
            cursor: not-allowed;
        }
        .toolbar-group button.icon-only {
            padding: 8px;
            width: 40px; 
            text-align: center;
        }
        
        /* Nuevo CSS para el Desplegable de Exportar */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropbtn {
            background-color: var(--color-primary);
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
            /* Asegurar que el estilo base del bot√≥n se aplique al dropbtn */
            line-height: 1.2; 
        }
        .dropbtn:hover {
            background-color: #3949ab;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0; /* Alinear a la derecha para que no se salga del contenedor */
            background-color: #f9f9f9;
            min-width: 220px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            overflow: hidden;
        }
        .dropdown-content a {
            color: #333;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            font-size: 0.9em;
            font-weight: normal;
        }
        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* Edici√≥n de texto flotante */
        #text-input {
            position: absolute;
            display: none;
            z-index: 1000; 
            padding: 5px;
            border: 1px solid var(--color-secondary);
            background: white;
            font-size: 10px;
            width: 120px;
        }
        
        /* ------------------------- */
        /* ZONA RIDER */
        /* ------------------------- */
        #editor-container { 
            display: block; 
            margin-bottom: 25px;
            width: 100%;
        }

        /* Contenedores de Vistas Separadas */
        #rider-lists-container, #needs-rider-editor-container {
            width: 100%;
            display: none; /* Oculto por defecto */
        }
        
        .rider-section-title {
            color: var(--color-primary);
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: 5px;
            margin-top: 35px;
            margin-bottom: 15px;
        }

        .rider-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .rider-table th, .rider-table td {
            border: 1px solid #ccc;
            padding: 10px; /* Reducido a 10px para celdas m√°s compactas */
            text-align: left;
        }
        .rider-table th {
            background-color: var(--color-primary);
            color: white;
        }
        .cell-input {
            width: 95%;
            border: none;
            background: transparent;
            padding: 10px 0; 
            margin: 0;
            box-sizing: border-box;
        }
        .btn-eliminar {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .hidden { display: none !important; }

        /* Estilos de Drag and Drop para filas de tablas */
        .rider-table tr {
            cursor: grab;
        }
        .rider-table tr.dragging {
            opacity: 0.5;
            background-color: #e0f7fa; 
        }
        .rider-table tr td:first-child input {
            width: 30px; 
            text-align: center;
            font-weight: bold;
        }

        /* Estilos para el icono personalizado */
        .icono-arrastrable.custom-icon-preview {
            padding: 0;
            width: 75px; 
            height: 75px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icono-arrastrable.custom-icon-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #file-input-label {
            display: block;
            background-color: #4CAF50; 
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        #file-input-label:hover {
            background-color: #45a049;
        }
        #custom-icon-preview-container {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        #custom-icon-preview-container img {
            max-width: 75px;
            max-height: 75px;
            object-fit: contain;
            border: 1px solid #ddd;
            padding: 5px;
        }
        
        /* Estilos espec√≠ficos de Quill (Ajuste de altura del editor) */
        #needs-rider-editor-quill {
            height: 300px; /* Altura fija para el editor */
            background-color: white;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        #needs-rider-editor-container .ql-toolbar.ql-snow {
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        
        /* ------------------------- */
        /* TOAST NOTIFICATIONS (NUEVO) */
        /* ------------------------- */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
        }
        .toast {
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            margin-bottom: 10px;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            transform: translateX(100%);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.success { background-color: #4CAF50; }
        .toast.error { background-color: #f44336; }
        .toast.info { background-color: #2196F3; }
    </style>
</head>
<body>
    <div id="toast-container"></div> 

    <div id="toolbar-gestion">
        
        <div class="toolbar-group">
            <button id="btn-stageplot" class="active" onclick="setView('stagePlot')">Stage Plot</button>
            <button id="btn-rider" onclick="setView('rider')">Rider T√©cnico</button>
            <button id="btn-needs-rider" onclick="setView('needsRider')">Rider Necesidades</button>
            
            <button onclick="newProject()" title="Empezar un nuevo proyecto"><i class="fas fa-file"></i> Nuevo</button>
            </div>
        
        <div class="toolbar-group" id="acciones-flotantes">
            
            <div class="dropdown">
                <button class="dropbtn"><i class="fas fa-file-export"></i> Exportar <i class="fas fa-caret-down"></i></button>
                <div class="dropdown-content">
                    <a href="#" onclick="exportarPlanoYListasHTML(); return false;">Plano y Listas (HTML)</a> 
                    <a href="#" onclick="generarStagePlotPDF(); return false;">Plano (PDF)</a>
                    <a href="#" onclick="exportarListasHTML(); return false;">Listas (HTML con formato)</a>
                    <a href="#" onclick="exportarListasCSV(); return false;">Listas (CSV datos puros)</a>
                </div>
            </div>
        </div>
    </div>
    
    <div id="documento-final">
        <div id="header-documento">
            <h1 id="header-title-editable" contenteditable="true" 
                onblur="saveStateSilencioso()" onkeypress="if(event.keyCode==13) this.blur()">
                STAGE PLOT & RIDER T√âCNICO
            </h1>
        </div>

        <div id="editor-container">

            <div id="main-workspace">
                
                <div id="herramientas">
                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Edici√≥n <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido abierto">
                        
                        <div class="control-grupo">
                            <label for="color-picker">Color:</label>
                            <input type="color" id="color-picker" value="#000000"> 
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="texto" style="width: 100px;">
                            <i class="fa-solid fa-font"></i> Texto Libre
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="tarima">
                            <i class="fa-solid fa-square"></i> Tarima
                        </div>
                        
                    </div>

                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Micr√≥fonos y DI <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <div class="icono-arrastrable" draggable="true" data-tipo="mic_vocal">
                            <img src="" data-icon-file="mic_dinamico_vocal.svg" alt="Mic Vocal" style="width: 30px; height: 30px;"> Mic. Vocal
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="mic_condensador">
                            <img src="" data-icon-file="mic_condensador.svg" alt="Mic Cond." style="width: 30px; height: 30px;"> Mic. Cond.
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="mic_instrumento">
                            <img src="" data-icon-file="mic_instrumento.svg" alt="Mic Inst." style="width: 30px; height: 30px;"> Mic. Inst.
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="cajadi">
                            <img src="" data-icon-file="di_box.svg" alt="DI" style="width: 30px; height: 30px;"> Caja DI
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="pie_micro">
                            <img src="" data-icon-file="pie_micro.svg" alt="Pie Mic" style="width: 30px; height: 30px;"> Pie Micro
                        </div>
                    </div>

                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Monitoreo y PA <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <div class="icono-arrastrable" draggable="true" data-tipo="monitor_wedge">
                            <img src="" data-icon-file="monitor_wedge.svg" alt="Mon Wedge" style="width: 30px; height: 30px;"> Monitor Cu√±a
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="caja_pa">
                            <img src="" data-icon-file="caja_pa.svg" alt="Caja PA" style="width: 30px; height: 30px;"> Caja PA
                        </div>
                         <div class="icono-arrastrable" draggable="true" data-tipo="subwoofer">
                            <img src="" data-icon-file="subwoofer.svg" alt="Subwoofer" style="width: 30px; height: 30px;"> Subwoofer
                        </div>
                    </div>
                    
                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Consolas, Rack y Cableado <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <div class="icono-arrastrable" draggable="true" data-tipo="consola_dig">
                            <img src="" data-icon-file="consola_digital.svg" alt="Consola Dig." style="width: 30px; height: 30px;"> Consola Dig.
                        </div>
                         <div class="icono-arrastrable" draggable="true" data-tipo="eq_rack">
                            <img src="" data-icon-file="eq_rack.svg" alt="EQ Rack" style="width: 30px; height: 30px;"> EQ Rack
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="fx_processor">
                            <img src="" data-icon-file="fx_processor.svg" alt="FX Proc." style="width: 30px; height: 30px;"> FX Proc.
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="manguera">
                            <img src="" data-icon-file="manguera_escenario.svg" alt="Manguera" style="width: 30px; height: 30px;"> Manguera
                        </div>
                         <div class="icono-arrastrable" draggable="true" data-tipo="cable_xlr">
                            <img src="" data-icon-file="cable_xlr.svg" alt="Cable XLR" style="width: 30px; height: 30px;"> Cable XLR
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="flight_case">
                            <img src="" data-icon-file="flight_case.svg" alt="Flight Case" style="width: 30px; height: 30px;"> Flight Case
                        </div>
                    </div>


                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Instrumentos y Muebles <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <div class="icono-arrastrable" draggable="true" data-tipo="midi_teclado">
                            <img src="" data-icon-file="midi_teclado.svg" alt="MIDI Teclado" style="width: 30px; height: 30px;"> MIDI Teclado
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="atril">
                            <img src="" data-icon-file="atril.svg" alt="Atril" style="width: 30px; height: 30px;"> Atril
                        </div>
                    </div>
                    
                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Iluminaci√≥n y Power <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <div class="icono-arrastrable" draggable="true" data-tipo="cabeza_movil">
                            <img src="" data-icon-file="cabeza_movil.svg" alt="Cabeza Movil" style="width: 30px; height: 30px;"> Cabeza M√≥vil
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="foco_par_led">
                            <img src="" data-icon-file="foco_par_led.svg" alt="Foco LED" style="width: 30px; height: 30px;"> Foco PAR LED
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="mesa_dmx">
                            <img src="" data-icon-file="mesa_dmx.svg" alt="Mesa DMX" style="width: 30px; height: 30px;"> Mesa DMX
                        </div>
                        <div class="icono-arrastrable" draggable="true" data-tipo="distr_power">
                            <img src="" data-icon-file="distribucion_power.svg" alt="Distr. Power" style="width: 30px; height: 30px;"> Distr. Power
                        </div>
                    </div>


                    <div class="categoria-header" onclick="toggleAcordeon(this)">
                        Icono Personalizado <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="categoria-contenido">
                        <input type="file" id="custom-icon-file-input" accept="image/png, image/jpeg, image/svg+xml" style="display: none;">
                        <label for="custom-icon-file-input" id="file-input-label">Subir Imagen</label>
                        <div id="custom-icon-preview-container">
                            
</div>
                    </div>
                </div>

                <div id="contenedor-escenario">
                    <button id="btn-zoom-reset" title="Volver a la escala original"><i class="fas fa-home"></i></button>
                    <button id="btn-eliminar-seleccionado-plano" disabled title="Eliminar el elemento seleccionado">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                    <div id="ruler-left"></div>
                    <div id="ruler-bottom"></div>
                    <div id="stage-konva-container"></div>
                    <input type="text" id="text-input" style="display: none;">
                </div>
            </div>
            
            <div id="rider-lists-container" style="display: none;">
                
                <h3 class="rider-section-title">Lista de Canales (Input List) üé§</h3>
                <button id="btn-add-input" onclick="agregarFilaManual('input')" style="margin-bottom: 10px;">+ A√±adir Input Manual</button>
                <table class="rider-table" id="input-list-table">
                    <thead>
                        <tr>
                            <th style="width: 5%;">CH</th>
                            <th style="width: 30%;">Fuente (Stage Plot Label)</th>
                            <th style="width: 25%;">Mic/DI Sugerido</th>
                            <th style="width: 30%;">Preamp / Notas</th>
                            <th style="width: 10%;">Acci√≥n</th>
                        </tr>
                    </thead>
                    <tbody id="lista-canales-body">
                        </tbody>
                </table>

                <h3 class="rider-section-title">Lista de Salidas (Output/Mix List) üéß</h3>
                <button id="btn-add-output" onclick="agregarFilaManual('output')" style="margin-bottom: 10px;">+ A√±adir Output Manual</button>
                <table class="rider-table" id="output-list-table">
                    <thead>
                        <tr>
                            <th style="width: 5%;">Mix</th>
                            <th style="width: 40%;">Destino</th>
                            <th style="width: 45%;">Notas / Eq</th>
                            <th style="width: 10%;">Acci√≥n</th>
                        </tr>
                    </thead>
                    <tbody id="lista-salidas-body">
                        </tbody>
                </table>
                
            </div>
            
            <div id="needs-rider-editor-container" style="display: none;">
                <h3 class="rider-section-title">Rider de Necesidades / Especificaciones T√©cnicas Adicionales üìù</h3>
                <div id="needs-rider-editor-quill" data-initial-content=""></div>
            </div>
        </div>
    </div>

    <script>
    // ----------------------------------------------------
    // CONFIGURACI√ìN DE ICONOS DE GITHUB üåê
    // ----------------------------------------------------
    // ‚ö†Ô∏è CONFIGURACI√ìN ACTUALIZADA CON TU REPOSITORIO
    const PLACEHOLDER_GITHUB_REPO = 'josereina69/rider-assets'; 
    // La ruta RAW usa la rama 'main' (o 'master') y la subcarpeta donde est√°n los archivos.
    const BASE_ICON_URL = `https://raw.githubusercontent.com/${PLACEHOLDER_GITHUB_REPO}/main/assets/svg/`; 

    // Mapeo de tipo de elemento a nombre de archivo (usando la extensi√≥n .svg)
    // ‚ö†Ô∏è Mapeo actualizado con la lista proporcionada:
    const CUSTOM_ICON_MAP = {
        'mic_vocal': 'mic_dinamico_vocal.svg',
        'mic_condensador': 'mic_condensador.svg',
        'mic_instrumento': 'mic_instrumento.svg',
        'cajadi': 'di_box.svg',
        
        'monitor_wedge': 'monitor_wedge.svg',
        'subwoofer': 'subwoofer.svg',
        'caja_pa': 'caja_pa.svg',

        'consola_dig': 'consola_digital.svg',
        'eq_rack': 'eq_rack.svg',
        'fx_processor': 'fx_processor.svg',
        'manguera': 'manguera_escenario.svg',
        'cable_xlr': 'cable_xlr.svg',
        'flight_case': 'flight_case.svg', 
        
        'midi_teclado': 'midi_teclado.svg',
        'atril': 'atril.svg',
        'pie_micro': 'pie_micro.svg',

        'cabeza_movil': 'cabeza_movil.svg',
        'foco_par_led': 'foco_par_led.svg',
        'mesa_dmx': 'mesa_dmx.svg',
        'distr_power': 'distribucion_power.svg',
        
        // 'tarima', 'texto', y 'custom_image' se manejan por separado
    };
    
    // ----------------------------------------------------
    // CONFIGURACI√ìN INICIAL Y OBJETOS GLOBALES 
    // ----------------------------------------------------
    
    const PIXELS_PER_METER = 50; // Constante: 50 p√≠xeles = 1 metro
    
    // Dimensiones Fijas (18m x 12m)
    const STAGE_WIDTH = 900; // 18m * 50px/m
    const STAGE_HEIGHT = 600; // 12m * 50px/m
    const GRID_SIZE = PIXELS_PER_METER; // 1 metro = 50px
    
    // Dimensiones en metros (para mostrar en las cotas/exportaci√≥n)
    const STAGE_WIDTH_M = STAGE_WIDTH / PIXELS_PER_METER; // 18m
    const STAGE_HEIGHT_M = STAGE_HEIGHT / PIXELS_PER_METER; // 12m
    
    const ICON_SIZE = 30; 
    const STORAGE_KEY = 'stageplot_project_v1'; 
    const CUSTOM_ICON_STORAGE_KEY = 'stageplot_custom_icon'; 

    let canalActual = 0;
    let salidaActual = 0;
    let activeTextNode = null;
    let transformer = null;
    let selectedShape = null;
    let currentView = 'stagePlot'; // Vista inicial
    let customIconDataURL = null; 
    let quill = null; // Variable global para el editor Quill
    
    // Variables de Zoom y Pan
    let scale = 1; 
    const scaleBy = 1.1; 

    const { jsPDF } = window.jspdf;

    const stage = new Konva.Stage({
        container: 'stage-konva-container',
        width: STAGE_WIDTH, 
        height: STAGE_HEIGHT, 
        draggable: true, 
    });

    let layer = new Konva.Layer();
    stage.add(layer);
    
    const colorPicker = document.getElementById('color-picker');
    const headerTitleElement = document.getElementById('header-title-editable'); 
    // BOT√ìN DE ELIMINAR REUBICADO
    const btnEliminarSeleccionadoPlano = document.getElementById('btn-eliminar-seleccionado-plano');
    const textInput = document.getElementById('text-input');
    const customIconFileInput = document.getElementById('custom-icon-file-input');
    const customIconPreviewContainer = document.getElementById('custom-icon-preview-container');
    const needsRiderEditorElement = document.getElementById('needs-rider-editor-quill');
    
    // ----------------------------------------------------
    // L√ìGICA DE TOAST NOTIFICATIONS (NUEVO) üí¨
    // ----------------------------------------------------

    /**
     * Muestra una notificaci√≥n temporal no bloqueante (Toast).
     * @param {string} message - Mensaje a mostrar.
     * @param {string} [type='info'] - Tipo de mensaje ('success', 'error', 'info').
     */
    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;

        container.appendChild(toast);

        // Muestra el toast
        setTimeout(() => {
            toast.classList.add('show');
        }, 10); // Peque√±o retraso para que la transici√≥n funcione

        // Esconde y elimina el toast despu√©s de 4 segundos
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                container.removeChild(toast);
            }, 500); // 500ms es el tiempo de la transici√≥n CSS
        }, 4000);
    }
    
    // ----------------------------------------------------
    // L√ìGICA DE PERSISTENCIA (GUARDAR Y CARGAR) üíæ
    // ----------------------------------------------------
    
    /** Guarda el estado sin mostrar un toast (para interacciones autom√°ticas). */
    function saveStateSilencioso() {
        const stageJSON = stage.toJSON();
        
        const inputListBody = document.getElementById('lista-canales-body').innerHTML;
        const outputListBody = document.getElementById('lista-salidas-body').innerHTML;
        // Guardar el contenido de Quill como HTML
        const needsRiderContent = quill ? quill.root.innerHTML : ''; 

        const projectData = {
            stage: stageJSON,
            inputList: inputListBody,
            outputList: outputListBody,
            canalActual: canalActual, 
            salidaActual: salidaActual,
            headerTitle: headerTitleElement.textContent, 
            stageScale: stage.scaleX(), 
            stagePos: stage.position(), 
            customIconDataURL: customIconDataURL,
            needsRiderContent: needsRiderContent,
            // Las dimensiones son Fijas, no se guardan
        };

        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
            // console.log("Guardado autom√°tico: Estado del proyecto actualizado."); // Se deja solo para depuraci√≥n
        } catch (e) {
            console.error('Error al guardar el proyecto en localStorage:', e);
            showToast('‚ùå Error al guardar el proyecto en localStorage.', 'error');
        }
    }

    // ELIMINADO window.saveProject (Ahora solo existe el guardado autom√°tico)

    window.loadProject = function() {
        const savedData = localStorage.getItem(STORAGE_KEY);
        if (!savedData) {
            drawGridAndFrame(); // Dibujar el lienzo si no hay datos guardados
            // console.log('No se encontr√≥ proyecto guardado. Iniciando lienzo vac√≠o.');
            return;
        }

        try {
            const projectData = JSON.parse(savedData);
            
            // 1. Cargar Konva Stage (dimensiones fijas)
            stage.destroyChildren();
            const tempContainer = document.createElement('div');
            const tempStage = Konva.Node.create(projectData.stage, tempContainer);
            
            layer = new Konva.Layer();
            stage.add(layer);
            
            // INICIO DE LA MODIFICACI√ìN: DIBUJAR CUADR√çCULA PRIMERO
            drawGridAndFrame(); // Asegura que el marco y la cuadr√≠cula est√©n en el fondo (Z-Index m√°s bajo)
            
            // 2. RE-ADJUNTAR ELEMENTOS M√ìVILES (se colocar√°n encima de la cuadr√≠cula)
            tempStage.find('.movable-group').forEach(group => {
                layer.add(group);
                
                group.on('dragend', saveStateSilencioso);
                group.on('transformend', function () { 
                    const label = group.children.find(c => c.name() === 'icon-label');
                    if (label) {
                        const groupWidth = group.width() * group.scaleX();
                        const groupHeight = group.height() * group.scaleY();
                        label.x(groupWidth / 2); 
                        label.y(-label.height() - 5); 
                        label.offsetX(label.width() / 2);
                    }
                    layer.draw();
                    saveStateSilencioso(); 
                });
                
                group.on('dblclick dbltap', function (e) {
                    e.cancelBubble = true;
                    const isFreeText = group.getAttr('data_type') === 'texto';

                    if (isFreeText) {
                        activeTextNode = group.children.find(c => c.name() === 'icon-shape');
                    } else {
                        activeTextNode = group.children.find(c => c.name() === 'icon-label');
                    }
                    
                    if(activeTextNode) {
                        showTextEditor(activeTextNode);
                    }
                });
                
                group.on('click tap', function (e) { selectShape(group); });
            });
            // FIN DE LA MODIFICACI√ìN

            // 3. Cargar Zoom/Pan
            scale = projectData.stageScale || 1;
            const pos = projectData.stagePos || { x: 0, y: 0 };
            stage.scale({ x: scale, y: scale });
            stage.position(pos);

            // 4. Cargar T√≠tulo
            headerTitleElement.textContent = projectData.headerTitle || "STAGE PLOT & RIDER T√âCNICO";
            
            // 5. Cargar Listas (innerHTML)
            document.getElementById('lista-canales-body').innerHTML = projectData.inputList || '';
            document.getElementById('lista-salidas-body').innerHTML = projectData.outputList || '';
            canalActual = projectData.canalActual || 0;
            salidaActual = projectData.salidaActual || 0;
            attachDragEvents();
            
            // 6. Cargar Custom Icon
            customIconDataURL = projectData.customIconDataURL || null;
            if (customIconDataURL) {
                updateCustomIconTool(customIconDataURL);
            } else {
                // Limpiar si no hay icono guardado
                customIconPreviewContainer.innerHTML = ''; 
            }

            // 7. Cargar Rider de Necesidades (Almacenar para Quill)
            const needsRiderContent = projectData.needsRiderContent || '';
            if (quill) {
                quill.root.innerHTML = needsRiderContent;
            } else {
                needsRiderEditorElement.setAttribute('data-initial-content', needsRiderContent);
            }
            
            layer.draw();
            // showToast('‚úÖ Proyecto cargado exitosamente.', 'success'); // Eliminado para no mostrar toast al inicio
        } catch (e) {
            console.error('‚ùå Error al cargar el proyecto:', e);
            showToast('‚ùå Error al cargar el proyecto: Los datos guardados son inv√°lidos. Revisa la consola para m√°s detalles.', 'error');
            drawGridAndFrame(); // Asegurar que al menos el lienzo se dibuje
        }
    }

    function saveState() {
        saveStateSilencioso();
    }
    // ----------------------------------------------------
    // L√ìGICA KONVA (MODIFICADA PARA IM√ÅGENES DE GITHUB)
    // ----------------------------------------------------

    /**
     * @param {string} label - Etiqueta a analizar.
     * @returns {{number: number, cleanLabel: string, listType: string}}
     */
    function extractChannelNumber(label) {
        let number = 0;
        let listType = '';
        let cleanLabel = label.trim();
        let match = null;

        // 1. Buscar el formato generado por el sistema: (Ch X), (Mix X)
        match = cleanLabel.match(/\s+\((Ch|Mix)\s*(\d+)\)$/i);
        
        if (match) {
            // Eliminar el formato del sistema para tener la etiqueta limpia
            cleanLabel = cleanLabel.substring(0, cleanLabel.lastIndexOf(match[0])).trim();
            listType = match[1].toLowerCase() === 'ch' ? 'input' : 'output';
            number = parseInt(match[2], 10);
        } else {
            // 2. Buscar formatos de entrada de usuario: chX, mixX, canal X, mon X, etc.
            match = cleanLabel.match(/(ch|can|mix|out|mon)\s*(\d+)/i);
            
            if (match) {
                const typeKeyword = match[1].toLowerCase();
                if (typeKeyword.startsWith('ch') || typeKeyword.startsWith('can')) {
                    listType = 'input';
                } else if (typeKeyword.startsWith('mix') || typeKeyword.startsWith('out') || typeKeyword.startsWith('mon')) {
                    listType = 'output';
                }
                
                number = parseInt(match[2], 10);
                
                // Eliminar el match (ej: "ch5") de la etiqueta para obtener el nombre limpio
                cleanLabel = cleanLabel.replace(match[0], '').trim();
            }
        }

        // Limpiar cualquier residuo de par√©ntesis o espacios m√∫ltiples
        cleanLabel = cleanLabel.replace(/[\(\)\[\]\{\}]/g, '').replace(/\s\s+/g, ' ').trim();

        // Si la etiqueta queda vac√≠a (e.g. el usuario solo escribi√≥ "ch5"), se usa el nombre original de la lista
        if (cleanLabel === '') {
            cleanLabel = label.replace(label.match(/\s+\((Ch|Mix)\s*(\d+)\)$/i)?.[0] || label.match(/(ch|can|mix|out|mon)\s*(\d+)/i)?.[0] || '', '').trim() || "Elemento";
        }
        
        return {
            number: number, 
            cleanLabel: cleanLabel, 
            listType: listType
        };
    }


    function createKonvaIcon(tipo, x, y, fill, imageDataURL = null) {
        const uniqueId = `konva-${Date.now()}`;
        let mainShape;
        let defaultLabel = tipo.charAt(0).toUpperCase() + tipo.slice(1);
        let canalAsignado = 0; // Se asigna al soltarlo en handleDrop
        let offsetX = 0;
        let offsetY = 0;
        let groupWidth = ICON_SIZE;
        let groupHeight = ICON_SIZE;
        let hasLabel = true;

        const iconFilename = CUSTOM_ICON_MAP[tipo];

        // 1. Elementos que usan IMAGEN DE GITHUB
        if (iconFilename) {
            const imageUrl = BASE_ICON_URL + iconFilename;
            
            // Intentar usar un nombre m√°s amigable para el label inicial
            const defaultLabels = {
                'mic_vocal': 'Mic Vocal',
                'mic_condensador': 'Mic Cond',
                'mic_instrumento': 'Mic Inst',
                'cajadi': 'DI Box',
                'monitor_wedge': 'Monitor',
                'subwoofer': 'Sub',
                'caja_pa': 'PA',
                'consola_dig': 'Consola',
                'eq_rack': 'EQ Rack',
                'fx_processor': 'FX Proc',
                'manguera': 'Snake',
                'cable_xlr': 'Cable XLR',
                'flight_case': 'Flight Case',
                'midi_teclado': 'Teclado MIDI',
                'atril': 'Atril',
                'pie_micro': 'Pie Mic',
                'cabeza_movil': 'Cabeza M√≥vil',
                'foco_par_led': 'Foco LED',
                'mesa_dmx': 'Mesa DMX',
                'distr_power': 'Power'
            };
            defaultLabel = defaultLabels[tipo] || defaultLabel;

            mainShape = new Konva.Image({
                x: 0,
                y: 0,
                image: new Image(), // Se cargar√° as√≠ncronamente
                width: ICON_SIZE,
                height: ICON_SIZE,
                name: 'icon-shape',
                data_type: tipo,
                data_id_vinculacion: uniqueId,
            });

            const img = new Image();
            img.onload = function() {
                mainShape.image(img);
                layer.draw();
            };
            img.onerror = function() {
                 console.error(`Error cargando el icono: ${imageUrl}. Usando fallback (rect√°ngulo).`);
                 // Fallback: Si la imagen falla, usamos un rect√°ngulo simple
                 mainShape.destroy(); 
                 const fallbackShape = new Konva.Rect({
                    x: 0, y: 0, 
                    width: ICON_SIZE, 
                    height: ICON_SIZE, 
                    fill: '#ccc', 
                    stroke: '#f00', 
                    strokeWidth: 2, 
                    name: 'icon-shape',
                    data_type: tipo,
                    data_id_vinculacion: uniqueId,
                 });
                 group.add(fallbackShape);
                 layer.draw();
            }
            img.src = imageUrl;
            
            offsetX = ICON_SIZE / 2;
            offsetY = ICON_SIZE / 2;
            groupWidth = ICON_SIZE;
            groupHeight = ICON_SIZE;
            hasLabel = true;
            
        } else if (tipo === 'texto') {
            hasLabel = false;
            defaultLabel = "Doble click para editar";
            mainShape = new Konva.Text({
                x: 0,
                y: 0,
                text: defaultLabel,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: fill,
                width: 150, 
                padding: 5,
                align: 'left',
                name: 'icon-shape', 
                data_type: tipo,
                data_id_vinculacion: uniqueId,
            });
            groupWidth = 150;
            groupHeight = mainShape.height();
            offsetX = 0;
            offsetY = 0;

        } else if (tipo === 'tarima') {
             // Tarima (Rect√°ngulo)
            defaultLabel = "Tarima";
            groupWidth = 200; // 4 metros
            groupHeight = 100; // 2 metros
            mainShape = new Konva.Rect({
                x: 0,
                y: 0,
                width: groupWidth,
                height: groupHeight,
                fill: '#e0e0e0',
                stroke: '#555555',
                strokeWidth: 2,
                name: 'icon-shape',
                data_type: tipo,
                data_id_vinculacion: uniqueId,
            });
            offsetX = groupWidth / 2;
            offsetY = groupHeight / 2;
            hasLabel = true;

        } else if (tipo === 'custom_image' && imageDataURL) {
            // Icono de Imagen Personalizada (subida localmente)
            defaultLabel = "Custom";
            mainShape = new Konva.Image({
                x: 0,
                y: 0,
                image: new Image(),
                width: ICON_SIZE,
                height: ICON_SIZE,
                name: 'icon-shape',
                data_type: tipo,
                data_id_vinculacion: uniqueId,
            });

            const img = new Image();
            img.onload = function() {
                mainShape.image(img);
                layer.draw();
            };
            img.src = imageDataURL;
            
            offsetX = ICON_SIZE / 2;
            offsetY = ICON_SIZE / 2;
            groupWidth = ICON_SIZE;
            groupHeight = ICON_SIZE;
            hasLabel = true; 

        } else {
             // Fallback para cualquier elemento no mapeado (ej: si se a√±ade un tipo nuevo sin imagen)
             mainShape = new Konva.Text({
                x: 0,
                y: 0,
                text: '?',
                fontSize: ICON_SIZE,
                fontFamily: 'Arial',
                fill: fill,
                name: 'icon-shape',
                data_type: tipo,
                data_id_vinculacion: uniqueId,
            });
            groupWidth = ICON_SIZE;
            groupHeight = ICON_SIZE;
            offsetX = ICON_SIZE / 2;
            offsetY = ICON_SIZE / 2;
        }

        const group = new Konva.Group({
            x: x,
            y: y,
            draggable: true,
            name: 'movable-group',
            data_id_vinculacion: uniqueId,
            data_type: tipo,
            data_canal: canalAsignado, // 0 initially
            offsetX: offsetX,
            offsetY: offsetY
        });

        group.add(mainShape);

        let label;
        if (hasLabel) {
            label = new Konva.Text({
                x: 0,
                y: 0,
                text: defaultLabel,
                fontSize: 10,
                fontFamily: 'Arial',
                fill: fill,
                align: 'center',
                name: 'icon-label',
                listening: false,
                rotation: 0,
            });

            group.add(label);

            // Posicionar la etiqueta por encima del centro del grupo
            label.x(groupWidth / 2);
            label.y(-label.height() - 5);
            label.offsetX(label.width() / 2);
        }

        group.on('dragend', saveStateSilencioso);
        
        group.on('transformend', function () {
            const labelNode = group.children.find(c => c.name() === 'icon-label');
            
            // L√≥gica de recolocaci√≥n de la etiqueta para iconos/formas escaladas
            if (labelNode) {
                const groupWidthScaled = group.width() * group.scaleX();
                const groupHeightScaled = group.height() * group.scaleY();

                // Para Tarimas (Rects) o Textos, la etiqueta se mantiene en el centro superior.
                if (group.getAttr('data_type') === 'tarima' || group.getAttr('data_type') === 'texto') {
                    labelNode.x(groupWidthScaled / 2);
                    labelNode.y(-labelNode.height() - 5);
                    labelNode.offsetX(labelNode.width() / 2);
                } else {
                    // Para iconos centrados, usar el centro del grupo (que es (0,0) con el offset aplicado)
                    // Las im√°genes escaladas deben ajustar la posici√≥n de la etiqueta al centro visual (0,0)
                    labelNode.x(0); 
                    labelNode.y(-labelNode.height() - 5);
                    labelNode.offsetX(labelNode.width() / 2);
                }
            }
            
            layer.draw();
            saveStateSilencioso();
        });


        // NUEVO: Manejo de doble click para texto libre (icon-shape) o etiqueta (icon-label)
        group.on('dblclick dbltap', function (e) {
            e.cancelBubble = true;
            const isFreeText = group.getAttr('data_type') === 'texto';

            if (isFreeText) {
                // Para texto libre, el texto es la forma principal
                activeTextNode = group.children.find(c => c.name() === 'icon-shape');
            } else {
                // Para todos los dem√°s, es la etiqueta
                activeTextNode = group.children.find(c => c.name() === 'icon-label');
            }
            
            if(activeTextNode) {
                showTextEditor(activeTextNode);
            }
        });
        
        group.on('click tap', function (e) {
            // Asegurar que solo se selecciona si no se est√° doblando click
            if (!e.cancelBubble) {
                selectShape(group);
            }
        });

        // Habilitar Transformador solo para grupos (tarimas, texto libre, etc.)
        if (tipo === 'tarima' || tipo === 'texto' || tipo === 'custom_image' || iconFilename) {
             group.setAttrs({
                // Configuraci√≥n predeterminada para el transformador. 
                rotatable: true,
                resizeEnabled: true,
             });
        }
        
        return group;
    }

    function removeTransformer() {
        if (transformer) {
            transformer.destroy();
            transformer = null;
        }
        selectedShape = null;
        // Deshabilitar el bot√≥n de eliminar
        btnEliminarSeleccionadoPlano.disabled = true;
        layer.draw();
    }

    function selectShape(shape) {
        removeTransformer();
        selectedShape = shape;

        transformer = new Konva.Transformer({
            node: shape,
            // Configuraci√≥n para permitir redimensionamiento y rotaci√≥n
            enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'rotater'],
            rotationSnaps: [0, 90, 180, 270], 
            // Limitar la escala m√≠nima para evitar que desaparezcan
            boundBoxFunc: function (oldBox, newBox) {
                if (newBox.width < 5 || newBox.height < 5) {
                    return oldBox;
                }
                return newBox;
            }
        });

        shape.getParent().add(transformer);
        
        // El selector de color solo afecta al color del icono/texto si no es una imagen
        const iconShape = shape.children.find(c => c.name() === 'icon-shape');
        if (iconShape && iconShape.getClassName() !== 'Image') {
             const shapeFill = iconShape.fill() || iconShape.stroke() || '#000000';
             colorPicker.value = shapeFill;
        }

        // Habilitar el bot√≥n reubicado
        btnEliminarSeleccionadoPlano.disabled = false;
        layer.draw();
    }

    // LISTENER ACTUALIZADO para el bot√≥n reubicado
    btnEliminarSeleccionadoPlano.addEventListener('click', () => {
        if (selectedShape) {
            const idVinculacion = selectedShape.getAttr('data_id_vinculacion');
            selectedShape.destroy();
            removeTransformer();
            eliminarFila(idVinculacion);
            showToast('üóëÔ∏è Elemento eliminado del plano.', 'info');
        }
    });
    
    colorPicker.addEventListener('input', function() {
        if (selectedShape) {
            const iconShape = selectedShape.children.find(c => c.name() === 'icon-shape');
            const iconLabel = selectedShape.children.find(c => c.name() === 'icon-label');

            if (iconShape && iconShape.getClassName() !== 'Image') {
                // Para rect√°ngulos (Tarima) o Textos de Icono, cambiar el color principal.
                iconShape.fill(this.value);
            }
            if (iconLabel) {
                 // Cambiar el color de la etiqueta
                 iconLabel.fill(this.value);
            }
            
            layer.draw();
            saveStateSilencioso();
        }
    });

    stage.on('click tap', function (e) {
        // Si el click es en el stage, el frame o la cuadr√≠cula, deseleccionar
        if (e.target === stage || e.target.name() === 'stage-frame' || e.target.name() === 'grid-line') {
            removeTransformer();
            textInput.style.display = 'none';
        }
    });

    function showTextEditor(textNode) {
        const stageKonvaContainer = document.getElementById('stage-konva-container');
        const stageKonvaRect = stageKonvaContainer.getBoundingClientRect();
        const nodePos = textNode.absolutePosition();

        textInput.value = textNode.text();
        textInput.style.display = 'block';

        // Ajuste de posici√≥n: el input de texto debe tener en cuenta el zoom/pan del stage
        const scaleFactor = stage.scaleX();
        const stagePos = stage.position();

        const absoluteX = stageKonvaRect.left + (nodePos.x * scaleFactor) + stagePos.x;
        const absoluteY = stageKonvaRect.top + (nodePos.y * scaleFactor) + nodePos.height + stagePos.y;

        textInput.style.left = absoluteX + 'px';
        textInput.style.top = absoluteY - textInput.offsetHeight / 2 + 'px';
        
        textInput.focus();

        textInput.onblur = function() {
            // El texto se actualiza en la tabla y en Konva mediante updateTableSourceLabelFromKonva
            textNode.text(textInput.value);

            const parentGroup = textNode.getParent();
            const dataType = parentGroup ? parentGroup.getAttr('data_type') : null;

            // Si es la etiqueta de un elemento vinculado, actualizar la lista (llamada clave para el reordenamiento)
            if (textNode.name() === 'icon-label') {
                const idVinculacion = parentGroup.getAttr('data_id_vinculacion');
                // Llama a la funci√≥n que actualiza la tabla y maneja el reordenamiento si el canal fue especificado
                updateTableSourceLabelFromKonva(idVinculacion, textInput.value); 
            } else if (dataType === 'texto') {
                // Si es un texto libre, debemos recalcular el alto y el transformador
                textNode.setAttr('height', 'auto'); // Permite que Konva recalcule el alto
                textNode.fire('transform'); // Disparar transformaci√≥n para actualizar el transformador
                saveStateSilencioso(); // Guardar el cambio del texto libre
            }

            textInput.style.display = 'none';
            layer.draw();
        }
    }

    // ----------------------------------------------------
    // L√ìGICA DRAG AND DROP (Herramientas a Escenario)
    // ----------------------------------------------------
    
    // Funci√≥n de ayuda para adjuntar el evento de drag a un icono de herramienta
    function attachToolIconDragEvent(iconEl) {
        iconEl.addEventListener('dragstart', function (e) {
            const tipo = this.getAttribute('data-tipo');
            e.dataTransfer.setData('text/plain', tipo);
            e.dataTransfer.effectAllowed = 'copy';
        });
    }

    // Adjuntar a iconos est√°ndar
    document.querySelectorAll('.icono-arrastrable:not(.custom-icon-preview)').forEach(attachToolIconDragEvent);

    // Configuraci√≥n del contenedor para aceptar el drop
    const stageKonvaContainer = document.getElementById('stage-konva-container');
    stageKonvaContainer.addEventListener('dragover', function (e) {
        e.preventDefault(); 
        e.dataTransfer.dropEffect = 'copy';
    });

    stageKonvaContainer.addEventListener('drop', handleDrop);

    function handleDrop(e) {
        e.preventDefault();
        removeTransformer(); 

        const tipo = e.dataTransfer.getData('text/plain');
        
        // 1. Obtener el rect√°ngulo del contenedor Konva en la pantalla
        const stageKonvaRect = stageKonvaContainer.getBoundingClientRect();
        
        // 2. Calcular la posici√≥n de drop relativa al Konva Stage (0,0 del canvas)
        const dropX = e.clientX - stageKonvaRect.left;
        const dropY = e.clientY - stageKonvaRect.top;

        // 3. Obtener la transformaci√≥n inversa (zoom y pan) del Stage
        const transform = stage.getAbsoluteTransform().copy();
        transform.invert();

        // 4. Aplicar la transformaci√≥n inversa para obtener la posici√≥n l√≥gica (x, y)
        const dropPoint = transform.point({ x: dropX, y: dropY });

        // Verificar que el punto de ca√≠da est√© dentro del l√≠mite del Stage (STAGE_WIDTH x STAGE_HEIGHT)
        if (dropPoint.x < 0 || dropPoint.x > STAGE_WIDTH || dropPoint.y < 0 || dropPoint.y > STAGE_HEIGHT) {
            // console.log("Elemento soltado fuera del √°rea del escenario.");
            showToast('Elemento soltado fuera del √°rea del escenario.', 'error');
            return;
        }

        let newIcon;
        if (tipo === 'custom_image' && customIconDataURL) {
            newIcon = createKonvaIcon(tipo, dropPoint.x, dropPoint.y, colorPicker.value, customIconDataURL);
        } else {
            newIcon = createKonvaIcon(tipo, dropPoint.x, dropPoint.y, colorPicker.value);
        }

        layer.add(newIcon);
        layer.draw();
        selectShape(newIcon);
        saveStateSilencioso();
        showToast('‚ûï Elemento a√±adido al plano.', 'success');


        const dataType = newIcon.getAttr('data_type');
        
        // Agregar a la lista de inputs/outputs solo si es un elemento relevante para el rider
        if (dataType !== 'tarima' && dataType !== 'custom_image' && dataType !== 'texto' && 
            dataType !== 'pie_micro' && dataType !== 'atril' && dataType !== 'consola_dig' &&
            dataType !== 'eq_rack' && dataType !== 'fx_processor' && dataType !== 'manguera' &&
            dataType !== 'cable_xlr' && dataType !== 'flight_case' && dataType !== 'cabeza_movil' &&
            dataType !== 'foco_par_led' && dataType !== 'mesa_dmx' && dataType !== 'distr_power'
        ) {
            const idVinculacion = newIcon.getAttr('data_id_vinculacion');
            
            // Obtener la etiqueta del icono (solo el nombre por defecto)
            const labelNode = newIcon.children.find(c => c.name() === 'icon-label');
            let initialLabelText = labelNode ? labelNode.text() : dataType.charAt(0).toUpperCase() + dataType.slice(1);

            // Al crear el icono, no hay informaci√≥n de canal en initialLabelText, pero se sigue la l√≥gica de inserci√≥n
            const { cleanLabel } = extractChannelNumber(initialLabelText);
            
            // Asignar el tipo de lista
            let listType = 'input';
            if (dataType === 'monitor_wedge' || dataType === 'subwoofer' || dataType === 'caja_pa') {
                listType = 'output';
            }
            
            // Usar la funci√≥n unificada para insertar en la siguiente posici√≥n libre (requestedChannel = 0)
            insertarFilaEnCanal(listType, dataType, idVinculacion, cleanLabel, 0); 
        }
    }
    
    // ----------------------------------------------------
    // L√ìGICA CUSTOM ICON (Imagen subida por el usuario)
    // ----------------------------------------------------

    function updateCustomIconTool(dataURL) {
        customIconDataURL = dataURL; 
        
        // 1. Limpiar el contenedor de previsualizaci√≥n
        customIconPreviewContainer.innerHTML = '';
        
        // 2. Crear la imagen de previsualizaci√≥n
        const img = document.createElement('img');
        img.src = dataURL;
        customIconPreviewContainer.appendChild(img);
        
        // 3. Crear el icono arrastrable con la clase custom-icon-preview
        let draggableIcon = document.querySelector('.icono-arrastrable[data-tipo="custom_image"]');
        if (!draggableIcon) {
            draggableIcon = document.createElement('div');
            draggableIcon.className = 'icono-arrastrable custom-icon-preview';
            draggableIcon.setAttribute('draggable', 'true');
            draggableIcon.setAttribute('data-tipo', 'custom_image');
            
            // A√±adir el nuevo elemento al contenedor de la categor√≠a
            // Asumiendo que el contenedor es el √∫ltimo .categoria-contenido
            const allCategories = document.querySelectorAll('.categoria-contenido');
            const lastCategory = allCategories[allCategories.length - 1];
            lastCategory.appendChild(draggableIcon);
            
            // Adjuntar evento de drag al nuevo icono
            attachToolIconDragEvent(draggableIcon); 
        }
        
        // 4. Actualizar el contenido del icono arrastrable
        draggableIcon.innerHTML = ''; 
        draggableIcon.appendChild(img.cloneNode(true));

        // 5. Guardar en localStorage
        localStorage.setItem(CUSTOM_ICON_STORAGE_KEY, dataURL);
        saveStateSilencioso();
        // showToast('üñºÔ∏è Icono personalizado cargado y listo para usar.', 'success'); // Comentado para no spammear al cargar el proyecto
    }
    
    customIconFileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                updateCustomIconTool(event.target.result);
                showToast('üñºÔ∏è Icono personalizado cargado y listo para usar.', 'success');
            };
            reader.readAsDataURL(file);
        }
    });

    // ----------------------------------------------------
    // L√ìGICA ZOOM Y REGLAS
    // ----------------------------------------------------
    
    stageKonvaContainer.addEventListener('wheel', (e) => {
        e.preventDefault(); 
        removeTransformer();

        const oldScale = stage.scaleX();
        const pointer = stage.getPointerPosition();
        
        // Direcci√≥n de zoom: Arriba (e.deltaY < 0) = Acercar
        const newScale = e.deltaY < 0 ? Math.min(oldScale * scaleBy, 4) : Math.max(oldScale / scaleBy, 0.2); // Limitar zoom entre 0.2x y 4x

        const mousePointTo = {
            x: (pointer.x) / oldScale,
            y: (pointer.y) / oldScale,
        };

        const newPos = {
            x: pointer.x - mousePointTo.x * newScale,
            y: pointer.y - mousePointTo.y * newScale,
        };

        stage.scale({ x: newScale, y: newScale });
        stage.position(newPos);
        scale = newScale;

        updateRulers(scale, stage.position());
        layer.draw();
        saveStateSilencioso();
    });

    document.getElementById('btn-zoom-reset').addEventListener('click', () => {
        scale = 1;
        stage.scale({ x: scale, y: scale });
        stage.position({ x: 0, y: 0 });
        updateRulers(scale, stage.position());
        layer.draw();
        saveStateSilencioso();
        showToast('üè† Vista del plano restablecida.', 'info');
    });

    stage.on('dragmove', () => {
        updateRulers(stage.scaleX(), stage.position());
    });

    /**
     * Dibuja o actualiza las marcas de cota basadas en la escala y posici√≥n del Stage Konva.
     */
    function updateRulers(currentScale, position) {
        const rulerBottomEl = document.getElementById('ruler-bottom');
        const rulerLeftEl = document.getElementById('ruler-left');
        rulerBottomEl.innerHTML = '';
        rulerLeftEl.innerHTML = '';

        // Estas son las dimensiones en metros (unidades de cota)
        const totalMetersX = STAGE_WIDTH_M;
        const totalMetersY = STAGE_HEIGHT_M;

        const panX = position.x;
        const panY = position.y;

        // Regla Horizontal (Eje X)
        // GRID_SIZE es PIXELS_PER_METER (50px)
        const startXMeter = Math.floor((-panX / (GRID_SIZE * currentScale))) ;
        const endXMeter = Math.ceil((STAGE_WIDTH - panX) / (GRID_SIZE * currentScale)) ;
        
        for (let m = 0; m <= totalMetersX; m++) {
            const xPosPxScaled = (m * GRID_SIZE) * currentScale + panX;
            
            // Asegurar que la marca est√© visible dentro del rango de la regla
            if (xPosPxScaled >= 0 && xPosPxScaled <= STAGE_WIDTH) {
                 // Solo dibujar n√∫meros en marcas principales (metros enteros)
                if (m % 1 === 0) { 
                    const tick = document.createElement('div');
                    tick.className = 'ruler-tick';
                    tick.style.left = (xPosPxScaled) + 'px';
                    tick.innerHTML = `${m}m`;
                    rulerBottomEl.appendChild(tick);
                }
            }
        }

        // Regla Vertical (Eje Y)
        const totalMetersTopToBottom = STAGE_HEIGHT_M;
        
        for (let m = 0; m <= totalMetersY; m++) {
            const yPosPxScaled = (m * GRID_SIZE) * currentScale + panY;
            
            // Asegurar que la marca est√© visible dentro del rango de la regla
            if (yPosPxScaled >= 0 && yPosPxScaled <= STAGE_HEIGHT) {
                 // Solo dibujar n√∫meros en marcas principales (metros enteros)
                 // Nota: El eje Y comienza en la parte superior (0m). 
                 // totalMetersTopToBottom - m da la distancia desde el fondo del escenario (el 0m del plano se entiende como la parte de atr√°s del escenario).
                if (m % 1 === 0) { 
                    const tick = document.createElement('div');
                    tick.className = 'ruler-tick';
                    tick.style.top = (yPosPxScaled) + 'px'; 
                    tick.innerHTML = `${totalMetersTopToBottom - m}m`;
                    rulerLeftEl.appendChild(tick);
                }
            }
        }
    }


    function drawGridAndFrame() {
        // Al dibujar la cuadr√≠cula, solo destruir elementos que NO son movibles
        layer.children.forEach(child => {
            if (child.name() !== 'movable-group') {
                child.destroy();
            }
        });

        // 1. Dibujar el marco del escenario
        // ESTE DEBE SER EL PRIMERO EN A√ëADIRSE PARA ESTAR EN EL FONDO ABSOLUTO
        const frame = new Konva.Rect({
            x: 0,
            y: 0,
            width: STAGE_WIDTH,
            height: STAGE_HEIGHT,
            stroke: '#1a237e',
            strokeWidth: 3,
            fill: '#ffffff',
            name: 'stage-frame'
        });
        layer.add(frame);
        // frame.moveToBottom(); <-- ELIMINADO para evitar invertir el Z-index

        // 2. Dibujar la cuadr√≠cula (visible por defecto)
        const totalMetersX = STAGE_WIDTH / GRID_SIZE;
        const totalMetersY = STAGE_HEIGHT / GRID_SIZE;

        for (let i = 0; i <= totalMetersX; i++) {
            const xPos = i * GRID_SIZE;
            const line = new Konva.Line({
                points: [xPos, 0, xPos, STAGE_HEIGHT],
                stroke: '#e0e0e0',
                strokeWidth: 1,
                name: 'grid-line',
                visible: true
            });
            layer.add(line); // A√±adido despu√©s del marco, por lo tanto, visible encima del fondo blanco.
            // line.moveToBottom(); <-- ELIMINADO
        }
        for (let j = 0; j <= totalMetersY; j++) {
            const yPos = j * GRID_SIZE;
            const line = new Konva.Line({
                points: [0, yPos, STAGE_WIDTH, yPos],
                stroke: '#e0e0e0',
                strokeWidth: 1,
                name: 'grid-line',
                visible: true
            });
            layer.add(line); // A√±adido despu√©s del marco y las l√≠neas X.
            // line.moveToBottom(); <-- ELIMINADO
        }

        // 3. Dibujar las cotas (Rulers)
        updateRulers(stage.scaleX(), stage.position());
        layer.draw();
    }


    // ----------------------------------------------------
    // L√ìGICA RIDER (Listas y Canales)
    // ----------------------------------------------------

    /**
     * Ren√∫mera los canales/mixes de una lista (Input o Output) y actualiza contadores.
     * Tambi√©n actualiza las etiquetas Konva si el n√∫mero de canal/mix ha cambiado.
     */
    function renumerarCanales(listType = null) {
        let nuevoCanalActual = 0;
        let nuevaSalidaActual = 0;

        if (listType === 'input' || listType === null) {
            const inputRows = document.querySelectorAll('#lista-canales-body tr');
            inputRows.forEach((row, index) => {
                const chInput = row.querySelector('.ch-input');
                if (chInput) {
                    const oldCh = chInput.value;
                    const newCh = index + 1;
                    
                    if (oldCh != newCh) {
                        chInput.value = newCh; // Actualizar el valor del input
                        // Si el canal cambi√≥, actualizar la etiqueta Konva para que refleje el nuevo n√∫mero
                        const idVinculacion = row.getAttribute('data-id-vinculacion');
                        const sourceInput = row.querySelector('input[data-label-tipo="source"]');
                        if (sourceInput) {
                            // Usar updateKonvaLabelFromTable para reconstruir la etiqueta correctamente
                            updateKonvaLabelFromTable(idVinculacion, sourceInput.value); 
                        }
                    }
                }
            });
            nuevoCanalActual = inputRows.length;
            canalActual = nuevoCanalActual;
        }

        if (listType === 'output' || listType === null) {
            const outputRows = document.querySelectorAll('#lista-salidas-body tr');
            outputRows.forEach((row, index) => {
                const chInput = row.querySelector('.ch-input');
                if (chInput) {
                    const oldCh = chInput.value;
                    const newCh = index + 1;
                    
                    if (oldCh != newCh) {
                        chInput.value = newCh; // Actualizar el valor del input
                        // Si el mix cambi√≥, actualizar la etiqueta Konva
                        const idVinculacion = row.getAttribute('data-id-vinculacion');
                        const destinationInput = row.querySelector('input[data-label-tipo="dest"]');
                        if (destinationInput) {
                            // Usar updateKonvaLabelFromTable para reconstruir la etiqueta correctamente
                            updateKonvaLabelFromTable(idVinculacion, destinationInput.value); 
                        }
                    }
                }
            });
            nuevaSalidaActual = outputRows.length;
            salidaActual = nuevaSalidaActual;
        }

        saveStateSilencioso();
    }


    /**
     * Crea un nuevo <tr> (fila de tabla) sin insertarla en el DOM.
     * Retorna el elemento de fila para su posterior inserci√≥n.
     */
    function crearFilaHTML(numero, tipo, idVinculacion, nombrePorDefecto, listaTipo) {
        const newRow = document.createElement('tr');
        newRow.setAttribute('data-id-vinculacion', idVinculacion);
        newRow.setAttribute('draggable', 'true');
        newRow.setAttribute('data-list-type', listaTipo);

        // onchange llama a updateKonvaLabelFromTable para reconstruir la etiqueta con el nuevo n√∫mero de canal
        const chInputHTML = `<input type="number" class="cell-input ch-input" value="${numero}" min="1" onchange="updateKonvaLabelFromTable('${idVinculacion}', this.value); renumerarCanales('${listaTipo}')" onkeyup="saveStateSilencioso()">`;
        
        // Limpiar el nombre de cualquier marcador de canal para el input de la tabla
        const sourceInputName = nombrePorDefecto.replace(/ \(Ch \d+\)/i, '').replace(/ \(Mix \d+\)/i, '').trim();

        if (listaTipo === 'input') {
            // L√≥gica de valores por defecto para Input
            let defaultMicDI = '';
            if (tipo.startsWith('mic_')) {
                defaultMicDI = tipo === 'mic_condensador' ? 'Mic Condensador' : 'Mic Din√°mico';
            } else if (tipo === 'cajadi') {
                defaultMicDI = 'DI Pasiva';
            } else if (tipo === 'midi_teclado') {
                 defaultMicDI = 'L√≠nea (Est√©reo o Mono)';
            }
            
            newRow.innerHTML = `
                <td>${chInputHTML}</td>
                <td><input type="text" class="cell-input" value="${sourceInputName}" data-label-tipo="source" onchange="updateKonvaLabelFromTable('${idVinculacion}', this.value)" onkeyup="saveStateSilencioso()"></td>
                <td><input type="text" class="cell-input" value="${defaultMicDI}" onchange="saveStateSilencioso()" onkeyup="saveStateSilencioso()"></td>
                <td><input type="text" class="cell-input" value="" onchange="saveStateSilencioso()" onkeyup="saveStateSilencioso()"></td>
                <td><button class="btn-eliminar" onclick="eliminarFila('${idVinculacion}')">X</button></td>
            `;
        } else { // listaTipo === 'output'
             // L√≥gica de valores por defecto para Output
            let defaultNotes = '';
            if (tipo === 'monitor_wedge') {
                defaultNotes = 'Mon. Cu√±a';
            } else if (tipo === 'subwoofer') {
                defaultNotes = 'Sub L/R (Proporcionado por PA)';
            } else if (tipo === 'caja_pa') {
                defaultNotes = 'PA L/R (Proporcionado por Sala)';
            }
            
            newRow.innerHTML = `
                <td>${chInputHTML}</td>
                <td><input type="text" class="cell-input" value="${sourceInputName}" data-label-tipo="dest" onchange="updateKonvaLabelFromTable('${idVinculacion}', this.value)" onkeyup="saveStateSilencioso()"></td>
                <td><input type="text" class="cell-input" value="${defaultNotes}" onchange="saveStateSilencioso()" onkeyup="saveStateSilencioso()"></td>
                <td><button class="btn-eliminar" onclick="eliminarFila('${idVinculacion}')">X</button></td>
            `;
        }
        
        attachDragEventsToRow(newRow);
        return newRow;
    }


    /**
     * Inserta la fila en la posici√≥n del canal solicitado, moviendo la fila existente si es necesario.
     * @param {string} listType - 'input' o 'output'.
     * @param {string} dataType - Tipo de elemento (mic, monitor, etc).
     * @param {string} idVinculacion - ID del elemento Konva.
     * @param {string} cleanLabel - Etiqueta sin (Ch X) o (Mix X).
     * @param {number} requestedChannel - Canal solicitado (0 para el siguiente libre).
     */
    function insertarFilaEnCanal(listType, dataType, idVinculacion, cleanLabel, requestedChannel = 0) {
        const tbodyId = listType === 'input' ? 'lista-canales-body' : 'lista-salidas-body';
        const tbody = document.getElementById(tbodyId);
        let targetIndex = -1;

        if (requestedChannel > 0) {
             // 1. Verificar si ya existe una fila en el canal solicitado
            const existingRow = tbody.querySelector(`tr[data-id-vinculacion="${idVinculacion}"]`);
            
            // Si la fila ya existe, la eliminamos primero para reinsertarla en la posici√≥n correcta
            if (existingRow) {
                 existingRow.remove();
            }

            // Mover las filas existentes si es necesario para liberar la posici√≥n
            if (requestedChannel <= tbody.rows.length) {
                targetIndex = requestedChannel - 1; 
            } else {
                 // Si el canal solicitado es mayor que el n√∫mero actual de filas, simplemente a√±adir al final.
                 targetIndex = tbody.rows.length;
            }
            
        } else {
            // 2. Si no se solicit√≥ canal, a√±adir al final.
            targetIndex = tbody.rows.length;
        }
        
        // Asegurar que el √≠ndice no sea negativo y est√© dentro de los l√≠mites
        targetIndex = Math.max(0, targetIndex);
        targetIndex = Math.min(targetIndex, tbody.rows.length);


        // 3. Crear la nueva fila HTML. 
        // Nota: El n√∫mero de canal en la fila creada ser√° temporal, se corregir√° con renumerarCanales.
        const newRow = crearFilaHTML(targetIndex + 1, dataType, idVinculacion, cleanLabel, listType);

        // 4. Insertar la nueva fila en la posici√≥n correcta (√çndice 0-based)
        if (targetIndex < tbody.rows.length) {
            tbody.insertBefore(newRow, tbody.rows[targetIndex]);
        } else {
            tbody.appendChild(newRow);
        }

        // 5. Renumerar TODA la lista para corregir canales y contadores.
        renumerarCanales(listType);
    }
    
    /**
     * Actualiza la etiqueta Konva cuando se edita en la tabla (Input/Output Name o Channel Number).
     * @param {string} idVinculacion - ID del elemento Konva.
     * @param {string} rawInputText - El valor del input de la tabla (Source/Destination).
     */
    window.updateKonvaLabelFromTable = function(idVinculacion, rawInputText) {
        const konvaElement = layer.find(`.movable-group[data_id_vinculacion="${idVinculacion}"]`)[0];
        if (!konvaElement) return;

        const label = konvaElement.children.find(c => c.name() === 'icon-label');
        if (!label) return;

        // 1. Obtener el n√∫mero de canal/mix actual de la tabla
        const row = document.querySelector(`tr[data-id-vinculacion="${idVinculacion}"]`);
        if (!row) return;

        const finalChannelNumber = row.querySelector('.ch-input').value;
        const listType = row.getAttribute('data-list-type');

        // 2. Limpiar el texto de cualquier referencia a canal/mix que pudiera haber
        // Se usa el valor de la tabla que ya fue limpiado por la funci√≥n de la tabla
        const cleanLabel = rawInputText.replace(/(ch|can|mix|out|mon)\s*\d+/i, '').replace(/[\(\)\[\]\{\}]/g, '').trim();
        
        // 3. Reconstruir la etiqueta con el n√∫mero de canal/mix
        const prefix = listType === 'input' ? 'Ch' : 'Mix';
        // La etiqueta final en Konva siempre usa el formato (Ch X) o (Mix X)
        const finalLabel = `${cleanLabel} (${prefix} ${finalChannelNumber})`;

        label.text(finalLabel);
        
        // Recalcular posici√≥n de la etiqueta
        const parentGroup = label.getParent();
        if (parentGroup) {
            const groupWidth = parentGroup.width() * parentGroup.scaleX();
            // Para iconos centrados, usar el centro del grupo (que es (0,0) con el offset aplicado)
            label.x(0); 
            label.y(-label.height() - 5);
            label.offsetX(label.width() / 2);
        }

        layer.draw();
        saveStateSilencioso();
    }

    /**
     * **CORRECCI√ìN CLAVE**
     * * Actualiza el campo "Source" en la tabla cuando se edita el texto en el plano Konva.
     * Reordena la lista si el usuario especific√≥ un canal (Ch X).
     * * @param {string} idVinculacion - ID del elemento Konva.
     * @param {string} rawText - El texto del label de Konva, que puede contener "mic ch5".
     */
    window.updateTableSourceLabelFromKonva = function(idVinculacion, rawText) {
        // 1. Limpiar el texto y extraer canal/mix.
        const { cleanLabel, number: requestedChannel, listType: extractedListType } = extractChannelNumber(rawText);
        
        // 2. Encontrar la fila y el elemento Konva
        const row = document.querySelector(`tr[data-id-vinculacion="${idVinculacion}"]`);
        const konvaElement = layer.find(`.movable-group[data_id_vinculacion="${idVinculacion}"]`)[0];
        
        if (!row || !konvaElement) return;

        const rowListType = row.getAttribute('data-list-type');
        const inputField = row.querySelector(`input[data-label-tipo="${rowListType === 'input' ? 'source' : 'dest'}"]`);

        if (inputField) {
            // 3. Update the source name in the table with the clean label
            inputField.value = cleanLabel; 

            // 4. Reordering logic: only if a channel was requested and the type matches.
            if (requestedChannel > 0 && extractedListType === rowListType) {
                const currentChannel = parseInt(row.querySelector('.ch-input').value);
                
                if (requestedChannel !== currentChannel) {
                    // Reorder the list by re-inserting the row
                    insertarFilaEnCanal(rowListType, konvaElement.getAttr('data_type'), idVinculacion, cleanLabel, requestedChannel);
                    showToast(`‚û°Ô∏è Elemento movido al canal ${requestedChannel}.`, 'info');
                    return; // Reordering calls saveState and updates Konva label, so we exit.
                }
            }
        }
        
        // 5. If no reordering, or if the source name changed but the channel didn't:
        // Update the Konva label to reflect the *correct* (Ch X) format based on the table's current channel.
        updateKonvaLabelFromTable(idVinculacion, cleanLabel); 
        
        saveStateSilencioso();
    }


    window.agregarFilaManual = function(listaTipo) {
        const idVinculacion = `manual-${Date.now()}`;
        const nombrePorDefecto = listaTipo === 'input' ? 'Elemento Manual' : `Mix Manual`;
        
        // Llama a la nueva funci√≥n de inserci√≥n, solicitando canal 0 (siguiente libre)
        insertarFilaEnCanal(listaTipo, 'manual', idVinculacion, nombrePorDefecto, 0); 
        showToast(`‚úèÔ∏è Fila manual a√±adida a la lista de ${listaTipo === 'input' ? 'Canales' : 'Salidas'}.`, 'success');
    }

    window.eliminarFila = function(idVinculacion) {
        // Eliminar fila de Input List
        let row = document.querySelector(`#lista-canales-body tr[data-id-vinculacion="${idVinculacion}"]`);
        let listType = 'input';
        
        if (!row) {
            // Si no est√° en Input List, buscar en Output List
            row = document.querySelector(`#lista-salidas-body tr[data-id-vinculacion="${idVinculacion}"]`);
            listType = 'output';
        }
        
        if (row) {
            row.remove();
            // Re-numerar la lista afectada
            renumerarCanales(listType);
            showToast(`üóëÔ∏è Fila eliminada de la lista de ${listType === 'input' ? 'Canales' : 'Salidas'}.`, 'info');
        }

        // Eliminar elemento de Konva si existe y no es manual
        const konvaElement = layer.find(`.movable-group[data_id_vinculacion="${idVinculacion}"]`)[0];
        if (konvaElement && konvaElement.getAttr('data_type') !== 'manual') {
            konvaElement.destroy();
            removeTransformer();
            layer.draw();
        }
        
        saveStateSilencioso();
    }


    // --- Drag and Drop de Filas (Reordenamiento) ---
    let draggedRow = null;

    function attachDragEventsToRow(row) {
        row.addEventListener('dragstart', function (e) {
            draggedRow = row;
            e.dataTransfer.effectAllowed = 'move';
            row.classList.add('dragging');
        });

        row.addEventListener('dragend', function () {
            draggedRow.classList.remove('dragging');
            draggedRow = null;
            renumerarCanales(row.getAttribute('data-list-type'));
            showToast('‚ôªÔ∏è Listas reordenadas.', 'info');
        });

        row.addEventListener('dragover', function (e) {
            e.preventDefault();
            const boundingBox = row.getBoundingClientRect();
            const offset = boundingBox.y + (boundingBox.height / 2);
            
            if (draggedRow && draggedRow.parentNode === row.parentNode) {
                if (e.clientY < offset) {
                    row.parentNode.insertBefore(draggedRow, row);
                } else {
                    row.parentNode.insertBefore(draggedRow, row.nextSibling);
                }
            }
        });
    }

    function attachDragEvents() {
        document.querySelectorAll('.rider-table tbody tr').forEach(attachDragEventsToRow);
    }
    
    // ----------------------------------------------------
    // UTILIDADES (Acorde√≥n, Vistas, Exportaci√≥n)
    // ----------------------------------------------------

    window.toggleAcordeon = function(header) {
        const content = header.nextElementSibling;

        // Cerrar todos excepto el que se va a abrir (o el que ya est√° abierto)
        document.querySelectorAll('.categoria-contenido').forEach(c => {
            if (c !== content && c.classList.contains('abierto')) {
                c.classList.remove('abierto');
                c.style.maxHeight = null;
            }
        });

        if (content.classList.contains('abierto')) {
            content.classList.remove('abierto');
            content.style.maxHeight = null;
        } else {
            content.classList.add('abierto');
            // Usar scrollHeight para calcular la altura din√°micamente
            content.style.maxHeight = content.scrollHeight + "px";
        }
    };

    /**
     * Gestiona la vista activa (Stage Plot, Listas o Rider de Necesidades).
     */
    window.setView = function(view) {
        currentView = view;
        const mainWorkspace = document.getElementById('main-workspace');
        const riderListsContainer = document.getElementById('rider-lists-container');
        const needsRiderEditorContainer = document.getElementById('needs-rider-editor-container');
        const allButtons = [
            document.getElementById('btn-stageplot'),
            document.getElementById('btn-rider'),
            document.getElementById('btn-needs-rider')
        ];

        allButtons.forEach(btn => btn.classList.remove('active'));

        // Ocultar todos los contenedores principales de trabajo
        mainWorkspace.style.display = 'none';
        riderListsContainer.style.display = 'none';
        needsRiderEditorContainer.style.display = 'none';

        // Mostrar el contenedor y activar el bot√≥n de la vista seleccionada
        if (view === 'stagePlot') {
            mainWorkspace.style.display = 'flex';
            document.getElementById('btn-stageplot').classList.add('active');
            // Recalcular cotas en caso de que se haya redimensionado la ventana mientras se estaba en otra vista
            updateRulers(stage.scaleX(), stage.position()); 
        } else if (view === 'rider') {
            riderListsContainer.style.display = 'block';
            document.getElementById('btn-rider').classList.add('active');
        } else if (view === 'needsRider') {
            needsRiderEditorContainer.style.display = 'block';
            document.getElementById('btn-needs-rider').classList.add('active');
        }
    }


    /**
     * Funci√≥n utilitaria para obtener el HTML formateado de las listas del Rider.
     */
    function getRiderListHTML(includeNeedsRider = false) {
        const inputListBody = document.getElementById('lista-canales-body').innerHTML;
        const outputListBody = document.getElementById('lista-salidas-body').innerHTML;
        
        // Reemplazar los inputs por su valor de texto para la exportaci√≥n
        const sanitizeTableHTML = (bodyHTML) => {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<table><tbody>${bodyHTML}</tbody></table>`;
            
            // Eliminar la columna de Acci√≥n (√∫ltimo <td>)
            tempDiv.querySelectorAll('tr').forEach(row => {
                const lastCell = row.lastElementChild;
                if (lastCell && lastCell.querySelector('.btn-eliminar')) {
                    row.removeChild(lastCell);
                }
            });

            // Reemplazar todos los <input> por el valor de su atributo 'value'
            tempDiv.querySelectorAll('input').forEach(input => {
                const textNode = document.createTextNode(input.value);
                input.parentNode.replaceChild(textNode, input);
            });
            
            return tempDiv.querySelector('tbody').innerHTML;
        };

        let riderHtmlContent = "";
        
        if (inputListBody.trim()) {
            riderHtmlContent += `
                <h3 class="rider-section-title">Lista de Canales (Input List) üé§</h3>
                <table class="rider-table">
                    <thead>
                        <tr>
                            <th style="width: 5%;">CH</th>
                            <th style="width: 30%;">Fuente (Stage Plot Label)</th>
                            <th style="width: 25%;">Mic/DI Sugerido</th>
                            <th style="width: 40%;">Preamp / Notas</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sanitizeTableHTML(inputListBody)}
                    </tbody>
                </table>
            `;
        }

        if (outputListBody.trim()) {
            riderHtmlContent += `
                <h3 class="rider-section-title">Lista de Salidas (Output/Mix List) üéß</h3>
                <table class="rider-table">
                    <thead>
                        <tr>
                            <th style="width: 5%;">Mix</th>
                            <th style="width: 45%;">Destino</th>
                            <th style="width: 50%;">Notas / Eq</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sanitizeTableHTML(outputListBody)}
                    </tbody
                </table>
            `;
        }
        
        let needsRiderContent = "";
        if (includeNeedsRider && quill) {
             needsRiderContent = quill.root.innerHTML;
             if (needsRiderContent.trim() && needsRiderContent.trim() !== '<p><br></p>') {
                riderHtmlContent += `
                    <h3 class="rider-section-title">Rider de Necesidades Adicionales üìù</h3>
                    <div style="padding: 15px; border: 1px solid #ddd; border-radius: 4px; background-color: #fff;">
                        ${needsRiderContent}
                    </div>
                `;
            }
        }
        
        return riderHtmlContent;
    }

    /**
     * Funci√≥n utilitaria para descargar archivos.
     */
    function downloadFile(content, fileName, mimeType) {
        const a = document.createElement('a');
        a.href = 'data:' + mimeType + ',' + encodeURIComponent(content);
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // ----------------------------------------------------
    // EXPORTACI√ìN A HTML (Plano + Listas)
    // ----------------------------------------------------

    window.exportarPlanoYListasHTML = function() {
        removeTransformer();
        const titleText = headerTitleElement.textContent || "Stage Plot y Rider T√©cnico";
        
        // 1. Obtener la imagen del Stage Plot sin la cuadr√≠cula
        const gridLines = layer.find('.grid-line');
        gridLines.forEach(line => line.visible(false));
        layer.draw(); // Dibujar sin cuadr√≠cula
        const stageDataURL = stage.toDataURL({ 
            mimeType: 'image/png', 
            quality: 1.0, 
            pixelRatio: 2 // Alta resoluci√≥n
        }); 
        gridLines.forEach(line => line.visible(true));
        layer.draw(); // Restaurar la cuadr√≠cula

        // 2. Obtener el HTML del Rider (incluyendo necesidades)
        const riderHtmlContent = getRiderListHTML(true);
        
        // 3. Estilos CSS para el HTML exportado
        const cssStyles = `
             :root { --color-primary: #1a237e; } 
             body { font-family: 'Arial', sans-serif; margin: 20px; color: #333; } 
             .rider-table { width: 100%; border-collapse: collapse; margin-top: 10px; margin-bottom: 30px; } 
             .rider-table th, .rider-table td { border: 1px solid #ccc; padding: 10px; text-align: left; font-size: 14px; } 
             .rider-table th { background-color: var(--color-primary); color: white; } 
             .stage-plot-container { max-width: 900px; height: 600px; margin: 20px auto; border: 3px solid #1a237e; box-shadow: 0 4px 10px rgba(0,0,0,0.1); } 
             @media print { .stage-plot-container { page-break-after: always; } } 
         `;

        // 4. Combinar todo en un √∫nico archivo HTML
        const fullHTMLContent = `
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <meta charset="UTF-8">
                <title>${titleText} - Stage Plot y Rider T√©cnico</title>
                <style>
                    ${cssStyles}
                </style>
            </head>
            <body>
                <h1 style="font-size: 1.8em; font-weight: 700; text-align: center; color: #1a237e; border-bottom: 3px solid #1a237e; padding-bottom: 12px; margin-bottom: 35px; width: 100%;">STAGE PLOT: ${titleText}</h1>
                
                <div class="stage-plot-container">
                    <img src="${stageDataURL}" alt="Stage Plot" style="width: 100%; height: 100%; object-fit: contain;">
                </div>
                
                ${riderHtmlContent}
                
                <p style="margin-top: 50px; font-size: 0.8em; color: #555;">Documento generado el ${new Date().toLocaleDateString('es-ES')}.</p>
            </body>
            </html>
        `;

        downloadFile(fullHTMLContent, titleText + "_Plano_y_Rider.html", 'text/html;charset=utf-8;');
        showToast('‚úÖ Documento (Plano y Listas) exportado.', 'success');
    }

    // ----------------------------------------------------
    // EXPORTACI√ìN A PDF (Solo Plano)
    // ----------------------------------------------------

    /**
     * Funci√≥n: Genera el Stage Plot como PDF.
     */
    window.generarStagePlotPDF = function() {
        removeTransformer();
        const titleText = headerTitleElement.textContent || "Stage Plot";

        // 1. Ocultar la cuadr√≠cula temporalmente
        const gridLines = layer.find('.grid-line');
        gridLines.forEach(line => line.visible(false));
        layer.draw(); // Redibujar la capa sin la cuadr√≠cula

        const stageDataURL = stage.toDataURL({ 
            mimeType: 'image/png', 
            quality: 1.0, 
            pixelRatio: 2 
        }); // Alta resoluci√≥n

        // 2. Restaurar la cuadr√≠cula
        gridLines.forEach(line => line.visible(true));
        layer.draw(); // Restaurar la cuadr√≠cula en el lienzo

        const pdf = new jsPDF('l', 'mm', 'a4');
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const padding = 10;
        const ratio = STAGE_WIDTH / STAGE_HEIGHT; 
        
        // Calcular dimensiones para que encaje el Stage Plot en el PDF
        let imgWidth = pdfWidth - 2 * padding;
        let imgHeight = imgWidth / ratio;
        
        if (imgHeight > pdfHeight - 2 * padding) {
            imgHeight = pdfHeight - 2 * padding;
            imgWidth = imgHeight * ratio;
        }

        const xPos = (pdfWidth - imgWidth) / 2;
        const yPos = (pdfHeight - imgHeight) / 2;

        // T√≠tulo
        pdf.setFontSize(18);
        pdf.setTextColor(26, 35, 126); // var(--color-primary)
        pdf.text("STAGE PLOT: " + titleText, pdfWidth / 2, padding + 5, { align: 'center' });

        // Imagen
        pdf.addImage(stageDataURL, 'PNG', xPos, yPos, imgWidth, imgHeight);
        
        // Footer/Fecha
        pdf.setFontSize(8);
        pdf.setTextColor(85, 85, 85);
        pdf.text(`Documento generado el ${new Date().toLocaleDateString('es-ES')}.`, pdfWidth - padding, pdfHeight - padding + 2, { align: 'right' });

        pdf.save(titleText + "_Plano.pdf");
        showToast('‚úÖ Plano exportado a PDF.', 'success');
    }


    // ----------------------------------------------------
    // EXPORTACI√ìN A HTML (Solo Listas Formateadas)
    // ----------------------------------------------------

    window.exportarListasHTML = function() {
        const titleText = headerTitleElement.textContent || "Rider T√©cnico";
        
        // 1. Obtener el HTML del Rider (incluyendo necesidades)
        const riderHtmlContent = getRiderListHTML(true);
        
        if (!riderHtmlContent.trim()) {
            showToast('‚ùå No hay listas de Input/Output o Rider de Necesidades para exportar.', 'error');
            return;
        }

        // 2. Estilos CSS
        const cssStyles = `
             :root { --color-primary: #1a237e; } 
             body { font-family: 'Arial', sans-serif; margin: 20px; color: #333; } 
             .rider-table { width: 100%; border-collapse: collapse; margin-top: 10px; margin-bottom: 30px; } 
             .rider-table th, .rider-table td { border: 1px solid #ccc; padding: 10px; text-align: left; font-size: 14px; } 
             .rider-table th { background-color: var(--color-primary); color: white; } 
             .rider-section-title { color: var(--color-primary); border-bottom: 2px solid var(--color-primary); padding-bottom: 5px; margin-top: 35px; margin-bottom: 15px; font-size: 1.5em; } 
         `;

        // 3. Combinar en HTML
        const fullHTMLContent = `
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <meta charset="UTF-8">
                <title>${titleText} - Listas Rider T√©cnico</title>
                <style>
                    ${cssStyles}
                </style>
            </head>
            <body>
                <h1 style="font-size: 1.8em; font-weight: 700; text-align: center; color: #1a237e; border-bottom: 3px solid #1a237e; padding-bottom: 12px; margin-bottom: 35px; width: 100%;">Listas Rider: ${titleText}</h1>
                ${riderHtmlContent}
                <p style="margin-top: 50px; font-size: 0.8em; color: #555;">Documento generado el ${new Date().toLocaleDateString('es-ES')}.</p>
            </body>
            </html>
        `;

        downloadFile(fullHTMLContent, titleText + "_Listas_Formato.html", 'text/html;charset=utf-8;');
        showToast('‚úÖ Listas exportadas a HTML.', 'success');
    }

    // ----------------------------------------------------
    // EXPORTAR A CSV (Datos puros, sin formato)
    // ----------------------------------------------------

    window.exportarListasCSV = function() {
        const title = headerTitleElement.textContent || "Rider_Listas";
        let csvContent = "";
        const delimiter = ',';

        function getTableCSV(tableId, sectionTitle) {
            const table = document.getElementById(tableId);
            const tbody = document.getElementById(tableId).querySelector('tbody');

            // NO exportar si la lista est√° vac√≠a
            if (!table || !tbody || tbody.rows.length === 0) return "";

            let sectionCSV = `"${sectionTitle}"\n`;

            // Encabezados (excluyendo la √∫ltima columna "Acci√≥n")
            const headerCells = Array.from(table.tHead.querySelector('tr').children);
            const headers = headerCells.slice(0, -1).map(th => `"${th.textContent.trim()}"`).join(delimiter);
            sectionCSV += headers + "\n";

            // Filas de datos (excluyendo la √∫ltima columna "Acci√≥n")
            const rows = Array.from(table.tBodies[0].rows);
            rows.forEach(row => {
                const rowData = Array.from(row.children).slice(0, -1).map(cell => {
                    const input = cell.querySelector('input');
                    const value = input ? input.value.trim() : cell.textContent.trim();
                    // Escapar comillas dobles y encerrar el valor
                    return `"${value.replace(/"/g, '""')}"`; 
                }).join(delimiter);
                sectionCSV += rowData + "\n";
            });

            return sectionCSV + "\n"; // A√±adir una l√≠nea extra de separaci√≥n
        }

        csvContent += getTableCSV('input-list-table', 'Lista de Canales (Input List)');
        csvContent += getTableCSV('output-list-table', 'Lista de Salidas (Output/Mix List)');

        if (csvContent.trim() === '') {
            showToast('‚ùå No hay datos en las listas de Input/Output para exportar a CSV.', 'error');
            return;
        }

        // Agregar el t√≠tulo del proyecto al inicio
        const finalCSV = `"${title}"\n\n${csvContent}`;

        downloadFile(finalCSV, title + "_Listas.csv", 'text/csv;charset=utf-8;');
        showToast('‚úÖ Listas exportadas a CSV.', 'success');
    }

    // ----------------------------------------------------
    // INICIALIZACI√ìN (Al cargar el DOM)
    // ----------------------------------------------------
    
    /**
     * Carga las im√°genes de GitHub en los elementos arrastrables del sidebar.
     */
    function loadSidebarImages() {
        document.querySelectorAll('.icono-arrastrable img[data-icon-file]').forEach(img => {
            const filename = img.getAttribute('data-icon-file');
            img.src = BASE_ICON_URL + filename;
            
            // Opcional: Manejar errores de carga
            img.onerror = function() {
                 img.style.border = '1px solid red'; // Mostrar borde rojo si falla
                 img.alt = 'Error';
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
        
        // 1. Inicializar el editor Quill
        const toolbarOptions = [
            [{ 'header': [1, 2, 3, false] }],
            ['bold', 'italic', 'underline', 'strike'], 
            ['blockquote', 'code-block'],
            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
            [{ 'indent': '-1'}, { 'indent': '+1' }],
            [{ 'color': [] }, { 'background': [] }],
            [{ 'font': [] }],
            [{ 'align': [] }],
            ['clean']
        ];

        quill = new Quill('#needs-rider-editor-quill', {
            modules: {
                toolbar: toolbarOptions
            },
            theme: 'snow',
            placeholder: "Escribe aqu√≠ cualquier requerimiento de hospitality, backline, iluminaci√≥n, o notas adicionales..."
        });

        // Evento para guardar autom√°ticamente el contenido de Quill al cambiar
        quill.on('text-change', saveStateSilencioso);


        // 2. Cargar el custom icon guardado si existe
        const savedCustomIcon = localStorage.getItem(CUSTOM_ICON_STORAGE_KEY);
        if (savedCustomIcon) {
            updateCustomIconTool(savedCustomIcon);
        }

        // 3. Cargar las im√°genes de GitHub en el sidebar
        loadSidebarImages(); 

        // 4. Cargar el proyecto o dibujar el lienzo vac√≠o
        loadProject(); 

        // 5. Cargar el contenido de Quill si se pas√≥ como data-initial-content
        const initialContent = needsRiderEditorElement.getAttribute('data-initial-content');
        if (quill && initialContent) {
            quill.root.innerHTML = initialContent;
            needsRiderEditorElement.removeAttribute('data-initial-content');
        }

        // 6. Colapsar acordeones de herramientas al inicio (excepto el primero)
        const allContents = document.querySelectorAll('.categoria-contenido');
        allContents.forEach(c => {
            if (!c.classList.contains('abierto')) {
                c.style.maxHeight = null;
            }
        });
        const firstContent = document.querySelector('.categoria-contenido.abierto');
        if (firstContent) {
            // Asegurar que el primero se muestre correctamente
            firstContent.style.maxHeight = firstContent.scrollHeight + "px"; 
        }
        
        // 7. Adjuntar eventos de drag and drop a las filas de la tabla
        attachDragEvents();
        
        // 8. Adjuntar eventos de arrastre a los iconos de herramientas est√°ndar
        document.querySelectorAll('.icono-arrastrable:not(.custom-icon-preview)').forEach(attachToolIconDragEvent);
        
        // 9. Asegurar que la vista inicial sea Stage Plot
        setView('stagePlot');
    });
    
    window.newProject = function() { 
        if (confirm('¬øEst√°s seguro de que quieres empezar un proyecto nuevo? Se perder√°n los cambios no guardados en el navegador.')) {
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(CUSTOM_ICON_STORAGE_KEY); 
            window.location.reload(); 
        }
    }
    
    </script>
</body>
</html>
